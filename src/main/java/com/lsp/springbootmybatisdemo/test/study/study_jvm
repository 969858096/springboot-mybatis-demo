


对象分配：
        1、对象布局
            1.1对象头：存放对象自身运行时数据（比如线程id、对象的分代年龄、对象偏向锁、锁的标志位、哈希值等）;类型指针（通过改指针可以该对象所对应的类型）
            1.2实例数据：程序代码中所定义的各种类型的字段内容
            1.3对齐填充：

        1、对象内存分配规则
            1.1.1：指针碰撞： 如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，
                            那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
            1.1.2：空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，
                          虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
            对象内存分配也存在线程安全性问题，解决方法是：
            1.2.1：使用过CAS配上失败重试，保证操作的原子性
            1.2.2：本地线程分配缓存
            1.2.3栈上分配：把对象打算分配在栈上（比如把对象的属性会转化为局部变量分配在方法中）
                1：开启-Server JVm运行模式，开启server模式才能进行逃逸分析
                    2：-XX:+DoEscapeAnalysis: 启用逃逸分析（默认是开启的）
                    3：-Xx：+EliminateAllocation  : 标量替换（默认打开）
                    对栈上分配发生影响的参数就是三个：-server  、-XX：+DoEscapeAnalysis 、 -XX:EliminateAllocation,这三个参数任何一个发生变化都不会发生栈上分配；


        2、对象访问方式
                    2.1：句柄：如果使用句柄访问方式，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，
                    而句柄中包含了对象实例数据和类型数据各自的具体地址信息。使用句柄方式最大的好处就是reference中存储的是稳定的句柄地址
                    在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
                    2.2：直接指针：如果使用该方式，Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，
                    reference中直接存储的就是对象地址。使用直接指针方式最大的好处就是速度更快，他节省了一次指针定位的时间开销。


Class类文件结构：
        1.1：class文件是一组以8位字节为基础单位的二进制流
        1.2：类似于结构体的伪结构类存储数据
        1.3：只有两种数据类型：无符号数和表，无符号数属于基本的数据类型：以u1 u2 u4 u8
        分别代表一个字节、二个字节、四个字节、八个字节的无符号数，无符号数可以用来描述数字、索隐引用、数量或者按照UTF-8编码构成的字符串。
        1.4:表是有多个无符号数或者其他表作为数据构成的复合数据类型，整个class文件本质上就是一张表

Class文件格式详解
        1.1：魔数与class文件的版本：每个class文件的头四个字节称为魔数，唯一作用是确定这个文件是否为一个被虚拟机接收的class文件
        1.2：常量池：主要存放字面量和符号引用；字面量比较接近java语言层面的常量概念，如文本字符串、声明为final的常量值等；
            符号引用则属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
        1.3：访问标志：用于识别一些类或者接层次的访问信息，包括这个class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话是佛丠声明为final等
        1.4：类索引、父类索引与接口索引结合：这三项数据来确定这个类的继承关系
        1.5：字段表集合：描述接口或者类声明的变量；字段包括类级变量以及实例变量
        1.6：方法表集合：描述了方法的定义
        1.7：属性表集合

字节码指令
        java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字以及跟随其后的零个或者多个代表此操作所需参数而构成。
        由于限定了虚拟机操作码的的长度为一个字节（即0-255），这以为值指令集的操作码数不超过256个
        大多数指令都包含了操作的所对应的数据类型信息，例如：
        iload指令是指将int的数据从局部变量表加载到操作栈中；
        大部分的指令都没有支持整形类型byte、char、short、boolean，而实际上是以int类型作为操作的数据类型
        1、加载和储存的指令：用于将数据从栈帧中的局部变量表加载到操作栈中
           iload:将int类型的数据类型从局部变量表加载到操作栈
           fload:将float类型的数据从局部变量表加载到操作栈
           istore:将一个数值从操作数栈储存到局部变量表
           fstore：将一个float类型的数据从操作数栈储存到局部变量表
        2、运算或算是指令：将两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作数栈顶
           加法指令：iadd、fadd
           减法指令：isub、fsub
           乘法指令：imul、fmul
        3、创建实例的指令：new
        4、访问字段的指令：getField、putField、getStatic、putStatic、
        5、方法调用指令：
            invokeVirtual:该指令用于调用对象实例方法，根据对象的实际类型进行分派（虚方法分派），java语言中最常见的分派方式
            invokeInterface:改指令用于调用接口方法，他会在运行时搜索一个实现了这个接口方法的对象，找出合适的方法进行调用。
            invokeSpecial:指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法、和父类方法
            invokeStatic：指令用于调用类方法（也就是静态方法）
            invokedNamic:指令用于在运行时动态解析出调用点限定符所引起的方法，并执行该方法；
            前边四条方法调用指令的分派逻辑都固话在java虚拟机内部，而invokeNamic指令的分派逻辑是有用户所设定的引导方法决定的。
            方法的调用执行与数据类型无关
        6、方法返回指令：ireturn（返回值类型是byte、char、short、boolean、int类型）、freturn（返回值类型为float型）、return（返回类型为void）
        7、异常处理指令：athrow
        8、同步指令：由monitorenter和monitorexit 两条指令来支持synchronized关键字的语义

方法调用详解：
        1、解析：
               虚拟机在程序编辑的时候就知道调用的方法是哪个了，类的静态方法、构造方法、私有方法都是属于方法调用的解析形式
        2、静态分派：
                和解析的实现是一样的效果，就是在编译器虚拟机就知道调用的方法了，方法的重载是静态分派的一种经典的体现，即方法的调用是根据变量的静态类型来决定的：
                例如HuMan h = new Man();HuMan是变量h的静态类型，而Man是变量h的实际类型，所以如果在发生重载，则调用的方法由变量的静态类型决定的
        3、动态分派：
                动态分派的经典体现是方法的重写，即在编译期虚拟机并不知道调用的方法是哪个，是在运行的时候由变量的实际类型决定的
                实现本质：在运行期，虚拟机会维护一张虚方法表，每个类一个虚方法表，虚方法表记录的是每个方法的实际入口；

类加载机制：
        1、类加载原理：
            虚拟机将字节码文件通过类的加载器加载进虚拟机内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的class对象，作为这个方法区类数据的访问入口

        2、加载流程（类的生命周期）：加载->验证->准备->解析->初始化->使用->卸载
            a:加载:通过类加载器完成，主要完成三件事
                1：通过类的全限定名来获取定义此类的二进制字节流(这一步实际上是在虚拟机外部类加载器)
                2：将这个类字节流代表的静态储存结构转化为方法区的运行时数结构
                3：在堆中生成一个代表此类的java.lang.class 对象，作为访问方法区这些数据结构的入口
            b:连接:这一步可以细分为：
                1：验证：此阶段主要确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。
                2：准备：进行内存的初始分配，给变量设置默认值；比如给int型的变量设置值为0
                3：解析：将符号引用解析为直接引用
            c:初始化：初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。
                     虚拟机会保证<client>方法执行之前，父类的<client>方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。
                     发生初始化的情况有且只有五种：
                        1：使用new关键字实例化对象、访问或者设置一个类的静态字段（被final修饰、编译器优化时已经放入常量池的例外）、调用类方法，都会初始化该静态字段或者静态方法所在的类。
                        2：初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。
                        3：反射调用
                        4：虚拟机启动时，用户会先初始化要执行的主类（含有main）
                        5：jdk 1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个方法所在类没有初始化，则先初始化。

        3、类加载器： 把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。
                      这样的好处在于，我们可以自定义加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。(自定义类加载器的应用场景：类加载器的加密和解密、热加载、OSGI等)
            1、系统自带的类加载器分三种：
                a:启动类加载器：加载存放在<JAVA_HOME>\bin目录下的类，是虚拟机识别的类库加载到虚拟机内存中
                b:扩展类加载器：加载存放在<JAVA_HOME\lib\ext目录下的所有类库，开发者可以直接使用
                c:应用程序类加载器：加载用户类路径上指定的类库，开发者可以直接使用，一般情况下这个就是程序中默认的类加载器

        4、双亲委派机制：
            1：双亲委派机制的工作过程：
                某个特定的类加载器在接收到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以加载则成功返回；
                只有父类加载器无法完成加载（它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载。
            2：双亲委派模型的优点：java类随着他的加载器一起具备了带有优先级层级关系，保证java程序稳定运行（在虚拟机中，类的唯一性根据类本身和他的类加载器 一块决定的）
                例如类java.lang.Object,它存放在rt.jart之中.无论哪一个类加载器都要加载这个类.最终都是双亲委派模型最顶端的Bootstrap类加载器去加载.
                因此Object类在程序的各种类加载器环境中都是同一个类.相反.如果没有使用双亲委派模型.由各个类加载器自行去加载的话.
                如果用户编写了一个称为“java.lang.Object”的类.并存放在程序的ClassPath中.那系统中将会出现多个不同的Object类.java类型体系中最基础的行为也就无法保证.应用程序也将会一片混乱.


垃圾收集GC:
            1、判断对象存活的方式
                1.1：引用计数法：通过判断对象的引用数量来判断对象是否存活，每一个对象都有一个计数器，被应用则加1,完成引用则减1
                     完成引用：当该对象的引用超过了生命周期，或者引用指向了其他对象，在某方法中定义一个对象的引用变量，方法结束之后变量被虚拟机栈自动释放，则该对象的引用也就结束了
                     任何一个引用技术为0的对象都被认为是不存货的，将被当成垃圾处理
                1.2：可达性分析算法：通过判断对象的引用链是否可达来决定对象是否要被回收，这个算法的基本思想就是通过一系列的称为 GC Root 的对象作为起点
                     从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Root 没有任何引用链相连的话，则证明此对象是不可达的，即认为它不可用
            2、哪些对象可以作为GCRoot
                2.1：虚拟机栈中的引用对象
                2.2：本地方法站中的引用对象
                2.3：活跃线程中的引用对象
                2.4：方法区中的常量引用变量
                2.5：方法区中的静态属性变量
            3、垃圾回收算法：
                3.1：标记-清楚算法：
                    标记：即从跟集合进行扫描，堆存活的对象做标记
                    清楚：对堆进行遍历，回收不可达的对象
                    缺点：清楚后回残生大量的不连续的内存碎片，可能导致后续在储存较大的对象的时候无法找到足够大的连续内存空间而触发在一次的垃圾收集

                3.2：复制算法：
                     将可用的内存分为对象面和空闲面，在对象面上创建对象，当对象面没有空间的时候，将还存活的对象复制到空闲面，然后将对象面的所有对象清除
                     好处：解决了内存碎片问题，顺序分配内存，简单高效，适用于对象存活率比较低的场景（比如年轻代），因为复制的内容少，所以效率高
                3.3：标记-整理算法：
                     标记：即从跟集合进行扫描，堆存活的对象进行标记
                     整理清除：移动所有存活的对象，按内存地址一次排序，然后将末端地址以后的内存全部回收。
                     优点：在标记-清除的基础上完成了移动，解决了内存碎片的问题
                     缺点：成本更高，适用于对象存活率较高的场景
                3.4：分代收集算法：
                     是一种组合的回收机制，也是 GC 的主流回收算法，将不同生命周期的对象分配到堆中的不同区域，采用不同的垃圾回收算法，提高 JVM 垃圾回收效率。
            4、不同内存区域的回收方式、
                4.1：年轻代：采用Minor GC回收，采用赋值算法，年轻代又分为Eden和from survivor to survivor
                            Eden区:对象刚被创建的时候存放在Eden区，如果Eden区存放在就放在Survivor区，甚至放到老年代中。
                            Survivor:Minor回收时，将Eden区存放的对象存放到From Survivor区，在一次回收的时候，又将From Survivor区的对象存放到To Survivor区然后清除 From Survivor，到达To Survivor 的对象年龄加1
                                     下一次Minor时循环这个操作（Eden->From Survivor->to Survivor 清除From Survivor,到 To Survivor 还存活的对象年龄加1），当年龄增加到15岁的时候，对象会进入到老年代
                4.2：老年代：存放生命周期较长的对象，使用标记-清除算法或者标记-整理算法
            5、垃圾收集器分类：
                5.1：年轻代常见的垃圾收集器
                    Serial收集器：采用复制算法；单线程收集；进行垃圾收集事必须暂停所有的工作线程；
                    ParNew收集器：采用复制算法；多线程收集；垃圾收集和工作线程可以同时执行
                    Parallel scavenge收集器：采用复制算法；多线程收集；更关注系统的吞吐量（吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)，相当于：CPU 运行用户代码时间与 CPU 总消耗时间的比值。）
                5.2：老年代常见的垃圾收集器
                    Serial old收集器：采用标记-整理算法；单线程收集；进行垃圾收集时，必须暂停所有的工作线程
                    ParNew old收集器：采用标记-整理算法：多线程收集；垃圾收集和工作线程可以同时执行，吞吐量优先
                    CMS收集器：采用标记-清除算法；垃圾收集线程和工作线程几乎可以同时工作
                    G1收集器：采用复制算法+标记-整理算法；支持并发和并行，使用多个CPU来缩短stop the world 的停顿时间，与用户线程并发执行，并且可以采用不同的线程去处理新产生的对象；基于标记-整理算法，有利于空间整合处理内存碎片问题
                    Stop the world:虚拟机要执行GC而停止应用程序的执行;
                    发生任何一种GC都会发生stop the world，当发生stop the world时除了GC线程不暂停之外，所有的线程都都会处于等待状态，知道GC任务完成；
                    多数GC优化就是通过减少stop the world的时间和次数来提高程序的性能