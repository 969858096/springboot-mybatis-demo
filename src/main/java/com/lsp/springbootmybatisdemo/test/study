如何栈上分配
    1：开启-Server JVm运行模式，开启server模式才能进行逃逸分析
    2：-XX:+DoEscapeAnalysis: 启用逃逸分析（默认是开启的）
    3：-Xx：+EliminateAllocation  : 标量替换（默认打开）
    对栈上分配发生影响的参数就是三个：-server  、-XX：+DoEscapeAnalysis 、 -XX:EliminateAllocation,这三个参数任何一个发生变化都不会发生栈上分配；

对象分配：
        1、对象内存分配规则
            1.1：指针碰撞： 如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，
                            那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
            1.2：空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，
                          虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。

        2、对象引用方式
                    2.1：直接指针
                    2.2：句柄


Class类文件结构：
        1.1：class文件是一组以8位字节为基础单位的二进制流
        1.2：类似于结构体的伪结构类存储数据
        1.3：只有两种数据类型：无符号数和表，无符号数属于基本的数据类型：以u1 u2 u4 u8
        分别代表一个字节、二个字节、四个字节、八个字节的无符号数，无符号数可以用来描述数字、索隐引用、数量或者按照UTF-8编码构成的字符串。
        1.4:表是有多个无符号数或者其他表作为数据构成的复合数据类型，整个class文件本质上就是一张表

Class文件格式详解
        1.1：魔数与class文件的版本：每个class文件的头四个字节称为魔数，唯一作用是确定这个文件是否为一个被虚拟机接收的class文件
        1.2：常量池：主要存放字面量和符号引用；字面量比较接近java语言层面的常量概念，如文本字符串、声明为final的常量值等；
            符号引用则属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
        1.3：访问标志：用于识别一些类或者接层次的访问信息，包括这个class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话是佛丠声明为final等
        1.4：类索引、父类索引与接口索引结合：这三项数据来确定这个类的继承关系
        1.5：字段表集合：描述接口或者类声明的变量；字段包括类级变量以及实例变量
        1.6：方法表集合：描述了方法的定义
        1.7：属性表集合

字节码指令
        java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字以及跟随其后的零个或者多个代表此操作所需参数而构成。
        由于限定了虚拟机操作码的的长度为一个字节（即0-255），这以为值指令集的操作码数不超过256个
        大多数指令都包含了操作的所对应的数据类型信息，例如：
        iload指令是指将int的数据从局部变量表加载到操作栈中；
        大部分的指令都没有支持整形类型byte、char、short、boolean，而实际上是以int类型作为操作的数据类型
        1、加载和储存的指令：用于将数据从栈帧中的局部变量表加载到操作栈中
           iload:将int类型的数据类型从局部变量表加载到操作栈
           fload:将float类型的数据从局部变量表加载到操作栈
           istore:将一个数值从操作数栈储存到局部变量表
           fstore：将一个float类型的数据从操作数栈储存到局部变量表
        2、运算或算是指令：将两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作数栈顶
           加法指令：iadd、fadd
           减法指令：isub、fsub
           乘法指令：imul、fmul
        3、创建实例的指令：new
        4、访问字段的指令：getField、putField、getStatic、putStatic、
        5、方法调用指令：
            invokeVirtual:该指令用于调用对象实例方法，根据对象的实际类型进行分派（虚方法分派），java语言中最常见的分派方式
            invokeInterface:改指令用于调用接口方法，他会在运行时搜索一个实现了这个接口方法的对象，找出合适的方法进行调用。
            invokeSpecial:指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法、和父类方法
            invokeStatic：指令用于调用类方法（也就是静态方法）
            invokedNamic:指令用于在运行时动态解析出调用点限定符所引起的方法，并执行该方法；
            前边四条方法调用指令的分派逻辑都固话在java虚拟机内部，而invokeNamic指令的分派逻辑是有用户所设定的引导方法决定的。
            方法的调用执行与数据类型无关
        6、方法返回指令：ireturn（返回值类型是byte、char、short、boolean、int类型）、freturn（返回值类型为float型）、return（返回类型为void）
        7、异常处理指令：athrow
        8、同步指令：由monitorenter和monitorexit 两条指令来支持synchronized关键字的语义

方法调用详解：
        1、解析：
               虚拟机在程序编辑的时候就知道调用的方法是哪个了，类的静态方法、构造方法、私有方法都是属于方法调用的解析形式
        2、静态分派：
                和解析的实现是一样的效果，就是在编译器虚拟机就知道调用的方法了，方法的重载是静态分派的一种经典的体现，即方法的调用是根据变量的静态类型来决定的：
                例如HuMan h = new Man();HuMan是变量h的静态类型，而Man是变量h的实际类型，所以如果在发生重载，则调用的方法由变量的静态类型决定的
        3、动态分派：
                动态分派的经典体现是方法的重写，即在编译期虚拟机并不知道调用的方法是哪个，是在运行的时候由变量的实际类型决定的
                实现本质：在运行期，虚拟机会维护一张虚方法表，每个类一个虚方法表，虚方法表记录的是每个方法的实际入口；

类加载机制：
        1、类加载原理：
            虚拟机将字节码文件通过类的加载器加载进虚拟机内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的class对象，作为这个方法区类数据的访问入口

        2、加载流程（类的生命周期）：加载->验证->准备->解析->初始化->使用->卸载
            a:加载:通过类加载器完成，主要完成三件事
                1：通过类的全限定名来获取定义此类的二进制字节流(这一步实际上是在虚拟机外部类加载器)
                2：将这个类字节流代表的静态储存结构转化为方法区的运行时数结构
                3：在堆中生成一个代表此类的java.lang.class 对象，作为访问方法区这些数据结构的入口
            b:连接:这一步可以细分为：
                1：验证：此阶段主要确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。
                2：准备：进行内存的初始分配，给变量设置默认值；比如给int型的变量设置值为0
                3：解析：将符号引用解析为直接引用
            c:初始化：初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。
                     虚拟机会保证<client>方法执行之前，父类的<client>方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。
                     发生初始化的情况有且只有五种：
                        1：使用new关键字实例化对象、访问或者设置一个类的静态字段（被final修饰、编译器优化时已经放入常量池的例外）、调用类方法，都会初始化该静态字段或者静态方法所在的类。
                        2：初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。
                        3：反射调用
                        4：虚拟机启动时，用户会先初始化要执行的主类（含有main）
                        5：jdk 1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个方法所在类没有初始化，则先初始化。

        3、类加载器： 把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。
                      这样的好处在于，我们可以自定义加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。(自定义类加载器的应用场景：类加载器的加密和解密、热加载、OSGI等)
            1、系统自带的类加载器分三种：
                a:启动类加载器：加载存放在<JAVA_HOME>\bin目录下的类，是虚拟机识别的类库加载到虚拟机内存中
                b:扩展类加载器：加载存放在<JAVA_HOME\lib\ext目录下的所有类库，开发者可以直接使用
                c:应用程序类加载器：加载用户类路径上指定的类库，开发者可以直接使用，一般情况下这个就是程序中默认的类加载器

        4、双亲委派机制：
            1：双亲委派机制的工作过程：
                某个特定的类加载器在接收到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以加载则成功返回；
                只有父类加载器无法完成加载（它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载。
            2：双亲委派模型的有点：java类随着他的加载器一起具备了带有优先级层级关系，保证java程序稳定运行（在虚拟机中，类的唯一性根据类本身和他的类加载器 一块决定的）
                例如类java.lang.Object,它存放在rt.jart之中.无论哪一个类加载器都要加载这个类.最终都是双亲委派模型最顶端的Bootstrap类加载器去加载.
                因此Object类在程序的各种类加载器环境中都是同一个类.相反.如果没有使用双亲委派模型.由各个类加载器自行去加载的话.
                如果用户编写了一个称为“java.lang.Object”的类.并存放在程序的ClassPath中.那系统中将会出现多个不同的Object类.java类型体系中最基础的行为也就无法保证.应用程序也将会一片混乱.


垃圾收集GC:



