编发编程：
    多线程

        基本概念：
            进程：每一个正在计算机内运行的应用程序都是一个进程，进程是操作系统进行资源调度分配的基本单位，是线程的集合
            线程：线程是进程的基本单位，每一个线程都是进程中一条执行路径，线程是宝贵的资源
            多线程：一个进程中有多条执行路径，也就是有多个线程在执行；例如迅雷同时下载多部电影、数据库连接池原理
                优点：提高程序的执行效率
            并发：在同一个进程内，多个线程共同竞争同一个cpu的执行权，宏观上看是多个线程同步执行，实际上是spu快速切换给线程分配执行权
            并行：指两个或两个以上事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源上（多核），同时执行。
            线程安全：在多线程并发情况下，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。
                解决线程安全问题：使用synchronized（内置锁）关键字或着线程锁（Lock）
            线程同步：当多个线程共享同一个资源,不会受到其他线程的干扰。
                作用：保证共享数据的读操作安全
                缺点：一个线程在执行共享数据的时候，其他的线程会处于阻塞状态，会降低程序的性能，多个线程需要判断锁，较为消耗资源
            死锁：同步中嵌套着同步；两个线程一双筷子的举例，若每个线程都持有一根筷子，且都在等待另一根筷子，若无外力作用，则两线程一直处于阻塞状态，这就叫死锁。
                解决方法：1、现让一个线程执行获得所有锁执行，另一个线程等待，等先执行的线程执行完毕，在让等待的线程去执行
            饥饿：排队阻塞，争取不到cpu而死，解决方法：设置线程的优先级尽量避免这种情况

        多线程的常见创建方式
            继承thread：
            实现Runnable：
            两者比较：实现效果相同，但是实现可以多实现，继承只能单继承，存在局限性
            start()和run（）区别:start()，开启线程，是线程进入就绪状态，等待spu分配资源，拿到cpu执行权才整整执行；run()线程的执行体，线程执行的内容

        。线程五状态：
            线程创建状态
            就绪状态
            运行状态
            阻塞状态
            结束

        线程调度：
            线程休眠 sleep()：线程进入阻塞状态，暂时让出cpu执行权，休眠时间结束又进入就绪状态；线程同步情况下，不会让出锁对象
            线程合并 join（）:A、B线程共享同一资源，A线程在执行的时候调用B线程的join(),A会处于阻塞转态，让出cpu执行权，B线程占用cpu执行权，待B线程执行完毕，A线程重新进入就绪状态
            线程礼让 yield():yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。线程之间拥有优先级，可以给线程手动设置优先级：threadA.setPriority()，一般来说线程优先级高的获得cpu执行权的机会大，单事无绝对
            线程中断：线程执行完毕之后自藕丁中断：public void stop()   线程执行过程中遇到异常中断：public void interrupt()   线程在执行的时候手动中断：public boolean isInterrupt()
            sleep()和join()区别：线程同步情况下，sleep（）不会让出锁对象，而join（）会让出锁对象

        线程之间的通信：多线程的同步需要线程之间的协同通信
            1、wait()/notify():wait（）使得正在运行的线程进入阻塞状态，等待唤醒；notify()唤醒阻塞的线程；
            2、ReentrantLock类加锁的线程的,Condition类的await()/signal()/signalAll()

        线程锁：
            内置锁：每一个java对象都可以当做一个实现线程同步的锁,称为内置锁；线程进入到同步代码块之前自动获取到锁，代码块执行完成或者是或者出现异常退出的时候会释放掉锁
                   synchronized：synchronized 修饰对象方法使用锁是当前this锁；synchronized 修饰静态方法使用锁是当前类的字节码文件
            Lock锁：在jdk1.5以后，在并发包中新增了Lock接口（以及相关的实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但是需要在使用的时候手动的上锁和解锁。
                    Lock接口可以尝试非阻塞的获取锁，当前线程尝试获取锁。如果这一时刻没有锁没有被其他的线程获取到，并成功的获取并持有锁。
                    Lock接口能被中断的获取锁，与synchronized不同，获取到锁的线程能够像响应中断，当获取到的锁被中断的时候，中断异常将会被抛出，同时锁会被释放
                    Lock接口在指定的时间之前获取到锁，如果时间到了依旧无法获取到锁，则返回。
            重入锁：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。
                    Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁
            读写锁：假设程序中存在一些对共享资源的读写操作，且写操作没有读操作那么频繁；在没有写操作的时候，两个线程读取同一资源没有任何问题，所以他是允许多线程同时读取
                    共享资源的；但是如果一个线程想去写这些共享数据，就不应该再有其他的读或者写线程对该共享资源进行操作。这时候读写锁就出现了
                    一句话总结：多个读写线程对共享资源进行读写操作的时候可以读--读、不可以读-写、写-写
            乐观锁和悲观锁：
                乐观锁：总是认为不会发生并发问题，每次去取数据的时候总认为不会有其他的线程对数据进行修改，因此不会上锁；
                        但是在更新数据的时候会判断在这之前有没有其他的线程对数据进行修改，一般使用版本号机制或者ca操作实现
                    version方式：一般是在数据库表中加一个数据版本号字段version，表示数据表被修改的次数，当数据表被修改时，version会+1,；当线程A要更新数据的时候
                        在读取数据的同时也会读取到version的值，在提交更新时，当刚才读取的version值和当前数据库中的version值相等时才更新；
                        个人理解，比如：A B两个线程要同时修改表中的同一条数据，假设现在这条数据的版本号是2；现在A、B两个线程同时读取到这条数据的版本号都是2；然后开始执行修改操作,但是都还没提交;
                        这时候B修改好了，要提交操作时发现表中的这条数据的版本号还是2，说明他在做修改操作的时候，没有其他线程对这条数据做修改操作，所以线程B很顺利的就提交了操作，并且这条数据的
                        版本好由2变成了3； 这时候A线程也修改好了，要提交修改操作的时候发现当前数据库表中的这条数据的版本号变成了3，跟他拿到的版本号2不一样，没办法，A线程就得放弃当前的提交操作，重新获取当前
                        版本的数据进行修改，一直重试，知道提交成功；、
                    CAS方式：即Compare and Swap 比较然后置换；涉及到三个操作数，分别是数据所在的内存值（V）、预期值（E：本地内存值）、新值(N);
                        当需要进行更新操作的时候，会先判断当前内存值与之前取到的值是否相等，若相等，则那新值更换内存值，若不相等则等于失败那就会重试，一般情况下是一个自选的操作，会不断的重试；
                悲观锁：总是假设最坏的情况，每次取数据的时候都会认为其他线程会对数据进行修改操作，所以为安全起见都会进行加锁（读锁、写锁），当其他线程需要访问数据时候
                        就会被挂起阻塞；悲观锁可以靠数据库实现、比如行锁、读锁、写锁等..都是在操作之前加的锁，在java中synchronized的思想是悲观锁
                        悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
                        乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。
            自旋锁和非自旋锁：
                自旋锁：实现原理同样也是CAS，在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。
                    如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。
                    而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。
                    自旋锁的缺点：自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。
                        反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。
                        所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。
                非自旋锁：自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
                         如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。
                         如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。
            分布式锁：如果想在不同的jvm中保证数据的同步，使用分布式锁；有数据库实现、缓存实现、zk分布式锁
            公平锁和非公平锁：
                公平锁：公平锁是指按照线程的申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获取到锁；
                    优点：等待锁的线程不会饿死；
                    缺点：整体的吞吐效率相对于非公平锁来说要低；等待队列中除了第一个线程以外，其他的线程都需要阻塞，Cpu唤醒线程的开销比非公平锁大；
                非公平锁：是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。
                    优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。
                    缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。
            偏向锁：很多情况下，竞争锁不是由多个线程取竞争，而是大概率由同一个线程在使用，这就造成了每次获取锁和释放锁所带来了很大的性能的消耗，这时候就用到了偏向锁；
            轻量级锁：多个线程可以同时持有锁，并且会使用自旋锁

        锁的状态：
            1、无锁：无锁就是没有对资源进行锁定，所有线程都能访问并且修改同一资源，单同时只有一个线程能修改成功；、
                    无锁的特点就是修改操作在循环内操作，线程会不断的尝试修改共享资源，如果没有冲突就会修改成功并且退出，否则就会继续循环尝试；
                    如果多个线程修改同一个值，必定会有一个修改成功，而其他修改失败的线程会不断的重试直到修改成功；CAS原理一级应用就是这种无锁的实现
            2、偏向锁：偏向锁是指同一段同步代码一直被一个线程所访问，那么改线程会自动获取到锁，降低获取锁的代价。
                       在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。、
                       其目标就是在只有一个线程执行同步代码块时能够提高性能。
             3、轻量级锁：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
             4、重量级锁：重量级锁是将除了拥有锁的线程以外的线程都阻塞。

        原子类：java.util.current.atomic,一个小型的工具包,支持单个变量上的无锁线程安全编程
            原子类的作用：保证数据安全，无阻塞，底层是cas无锁机制
            什么是CAS：即Conpare and Swap ，就是比较在置换，CAS是CPU的一个指令，由CPU保证原子性  ：jMM(主内存：共享变量、本地内存：共享变量的副本)---三个变量---比较置换（本地方法，c++是对java提供的接口）---失败重试
                      jdk1.5增加了并发包java.util.current.*,其下边的类使用了CAS算法，实现了区别synchronized同步锁的一种乐观锁；jdk1.5之前java是靠synchronized关键字保证同步的，这是一种独占锁，也是悲伤锁
            CAS算法的理解：
                1、与锁相比，使用比较置换（CAS）会使程序看起来更加的复杂一些，但是由于他的非阻塞性，使得他天生的免疫死锁问题；并且线程间的相互影响也远远比基于锁的方式要小；
                    更为重要的是，使用无锁的方式完全没有锁的竞争带来的开销，也没有线程间的频繁调度带来的开销，因此他会比基于锁的方式拥有更优越的性能
                2、无锁的好处：在高并发的情况下，他比有锁的程序拥有更加好的性能；天生对死锁问题进行免疫
                3、cas底层算法过程：他包含三个参数，分别是V(表示要更新的值)、E(预期值)、N(新值)；仅当V等于E的时候，才会将V值设置为N值；
                    如果V！= E,说明已经有其他的线程做了更新，则当前线程什么都不做，最后CAS返回当前V的真实值
                4、简单理解Cas：CAS需要你给一个期望值，也就是说你认为这个变量现在应该是怎么样的；如果变量不是你想象的那样，那说明他已经被被人修改了
                    那么你就重修尝试再次修改；失败之后可以放弃操作也可以重试
            CAS缺点
                1、(ABA问题)：如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？
                答案是不一定如果在，这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。
                针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性
                2、循环时间长开销大：CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
                3、只能保证一个共享变量的原子操作：对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
                Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。
            常用原子类：这些原子类都运用了无锁的概念，有的地方直接使用Cas操作的线程安全，底层是cas无锁机制，do..while 比较置换  失败重试 ，可以归属于乐观锁
                1、原子更新基本类型 例如：AtomicInteger  AtomicLong   AtomicBoolean
                2、原子更新数组类型 例如：AtomicIntegerArray
                3、原子更新引用类型 例如：AtomicReference<V>
                4、原子更新属性类型 例如：AtomicIntegerFieldUpdate<V>

        AQS：https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html


        多线程的三大性质：
            原子性：一个或者多个操作要么全部执行不受其他因素的影响，要么全部不执行；典型例子：银行转账
            可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值
            有序性：程序执行的顺序按照代码的先后顺序执行；一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，
                    它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
                    重排序在对单线程是不会有问题的，但是对于多线程就不一定了

        java内存模型（JMM）:JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。
            JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：
            线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。
            本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

        volatile:一旦某个线程修改了被volatile修饰的属性，修改后的属性就会被立即刷新到主内存中，当有其他的线程需要读取时，可以获取到修改后的值；
                在Java中为了加快程序的运行效率，对一些变量的操作通常是放在寄存器或者cpu的缓存上，之后才会同步到住内存中；而加了volatile是直接把变量读到主内存中；
                volatile保证了线程的可见性并且禁止重排序（重要）它相当于轻量级锁，但是不能保证原子性;
                volatile性能：volatile的读性能与普通变量几乎相同，但是写操作稍慢，因为他需要再本地代码中插入许多内屏指令来保证处理器不发生乱序现象

        volatile与synchronized的区别：
            1、volatile虽然保证了可见性但是并不能保证原子性；synchronized保证原子性和可见性（可见性：一个线程修改了共享变量，其他的线程能读到修改后的值）
            2、性能方面：synchronized是使多线程同步，防止同一时刻多个线程对共享数据进行写操作，其他线程就会处于阻塞状态；
            而在某些情况下，volatile的性能要优于synchronized,但是volatile是无法替代synchronized的，因为他无法保证线程的原子性；并且volatile还有一个缺点就是如果大量使用的话，cpu的缓存就用不上了，所以性能相对来说也会降低
            为什么volatile不能保证原子性？
                问题来了，既然它可以保证修改的值立即能更新到主存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？
                首先需要了解的是，Java中只有对基本类型变量的赋值和读取是原子操作，如i = 1的赋值操作，但是像j = i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。
                所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。
                如果使用volatile修饰,它只能保证第一步是从主内存取得最新值和指令不被重新排序.
                例如:
                i++;
                这条代码可以分为3个步骤:
                    1.从主内存取值;
                    2.执行+1;
                    3.值重新写回主内存
                从主内存取到最新的值a=1,线程A执行完+1操作(a=2),如果这个时候线程A让出时间片,其他线程修改a的值为5,线程A继续执行,把a=2写如到主内存.这个时候就线程不安全了.主要原因就是
                把值写回到主内存时,并没有判断主内存的最新值和之前取到的值一样就写回主内存了.所以,volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性.




        并发队列：阻塞与非阻塞：入列（添加队列），出列（获取队列）的时候线程是否会发生阻塞
            1：非阻塞式队列：例如-ConcurrentLinkedQueue（无界队列，不设大小，其实底层式用扩容实现的，看起来是无界）
                ConcurrentLinkedQueue:是一个适用于高并发场景下的队列，通过无锁的方式，实现高并发状态下的高性能，通常ConcurrentLinkedQueue的性能要优于Blocking，它是一个基于连接节点的无界线程安全队列，改队列遵循现金先出的原则
            2：阻塞式队列：例如-BlockingQueue（有界队列，大小式有限制的）
                阻塞：队列容器满了，则往队列容器中添加队列的操作会阻塞（等待时间可以设置），直到队列容器中有空闲位置；当队列容器中的为空了，则试图从容器中获取队列的操作会被阻塞，直到生产者往队列容器中生产存放队列，则继续从中获取队列
                ArrayBlockingQueue:是一个有边界的阻塞阻塞队列，他的内部实现是一个数组，有边界就是要指定队列大小
                LinkedBlockingQueue:阻塞队列的大小是可选的，如果我们初始化一个大小，他就是有界的，否则他就是无界的，无界的不指定具体大小，则存在一个默认最大值：Integer.MAX_VALUE  2^31-1；内部基于单向链表
                PriorityBlockingQueue:是一个没有边界的队列
                SynchronousQueue：队列内部仅允许容纳一个元素，当一个线程插入一个元素后 被阻塞，除非这个元素被其他的线程消费

        线程池：
            概念：储存可复用线程的池叫线程池，Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池；底层是阻塞式队列（防止队列容器溢出导致数据丢失）
                 使用线程池的三个好处
                 1、降低资源消耗：通过重复利用已经创建的线程降低线程创建和销毁锁造成的消耗（线程五状态）
                 2、提高响应速度：当任务到达时，可以不需要等待线程的创建就可以立即执行
                 3、提高线程的可管理性：线程是稀缺的资源，如果无限的创建，不仅会消耗系统的资源，还会降低系统的稳定性,使用线程池可以进行统一分配、调优和监控；但是要合理利用
            创建线程池的参数： new ThreadPoolExecutor(CorePoolSize, maximumPoolSize,keepAliveTime, TimeUnit,new SynchronousQueue<Runnable>());
                1、CorePoolSize:核心线程数（工作线程数），实际在执行的线程的个数；当任务线程数大于核心数，则多余的会存到缓存队列；核心线程数小于等于最大线程数
                2、maximumPoolSize：线程池最大的线程数，他表示的是线程池中最多能创建多少个线程
                3、keepAliveTime：线程的空闲时间
                4、SynchronousQueue：缓存队列
            线程池的四种创建方式：
                1、Executors.newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
                2、Executors.newFixedThreadPool ：创建一个固定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
                3、Executors.newScheduledThreadPool :创建一个固定长度的线程池，支持定长以及周期性任务执行
                4、Executors.newSingleThreadExecutor :创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
            线程池原理分析：提交一个任务到线程池中，线程池的处理流程如下：
                1、先判断线程池中的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务，否则进入下一个流程；（敢死队是否已经满，若未满，则新创建一个加入敢死队，否则下一个流程）
                2、线程池判断线程缓存队列是否已经满了，如果没有满，则把新提交的任务储存在这个缓存队列中，如果队列缓存满了，则进入下一个流程
                3、判断线程池中创建的线程数目是否已经达到规定的最大的线程数目，如果没有，则创建一个新的工作线程，否则交给饱和策略来处理这个任务；
            合理配置线程池：看任务执行情况，判断是IO密集型还是cpu密集型
                IO密集型：该任务会产生大量的IO阻塞，比如请求、读取数据库、循环IO操作等都可能发生阻塞，如果是在单线程的情况下，解决这种情况，可以使用多线程取解决；
                        这时候线程池最大的线程数配置为 2*cpu的核数，比如我的电脑是八核的，那么我的最大线程数可以配置为16
                CPU密集：CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。这时候没有产生阻塞情况，cpu不用等待可以一直快速执行，多任务的时候也是采用多线程取取提高程序的运行效率
                        cpu密集不用配置过多的线程数量，线程池配置的最大线程数为cpu核数就行，配置多大，造成浪费；比如我的电脑是八核的，那么最大线程数配置为8就行

        callable和Future: 在Java中，创建线程一般有两种方式，一种是继承Thread类，一种是实现Runnable接口。然而，这两种方式的缺点是在线程任务执行结束后，无法获取执行结果。
                          我们一般只能采用共享变量或共享存储区以及线程通信的方式实现获得任务结果的目的。Java提供了使用Callable和Future来实现获取任务结果的操作。
            Callable:Callable用来执行任务，产生结果;Callable与Runnable的差别在于Callable的Call方法带有反省返回值
            Future:Future用来异步获取结果。
            Future模式：Future模式的核心在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑；
                        比如：对于多线程，如果线程A要等待线程B的结果，那么线程A没必要等待B，直到B有结果，可以先拿到一个未来的Future，等B有结果是再取真实的结果。
                        经常举的一个例子就是：网络图片的下载，刚开始是通过模糊的图片来代替最后的图片，等下载图片的线程下载完图片后在替换。而在这个过程中可以做一些其他的事情。
                        自己的理解：比如说你煮饭的时候又想完游戏，但是如果你是用柴火煮饭的，那么你玩游戏的时候，就可能完一会游戏又得跑去看看柴火，就会影响你玩游戏，虽然也可以玩，但是断断续续的。极大影响游戏体验
                        但是如果你是用电饭煲，那你插上电就不用管了，直接一边电饭煲煮饭，你玩你的游戏，饭熟了，你游戏可能也打完了，完全不影响你玩游戏，电饭锅会自己停止，你直接那碗取盛饭就行


        Disruptor:disruptor是一个高性能队列，是一个开源的并发框架,它使用观察者模式，主动将消息推送给消费者，而不是等消费者从队列中取；在无锁的情况下实现了队列（RingBuffer）的并发操作，性能远高于BlockingQueue;
            Disruptor是一个高性能的异步处理框架、或者可以认为是最快的消息框架、观察者模式的实现、事件监听的实现、可以理解为是高性能的“生产者-消费者”模式





        思考题、面试题：
            1、假设有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行，？
                ---使用线程合并方法进行线程的一个调度，在T2执行的时候调用T1.join,让T1先执行完毕；T3执行的时候调用T2.join（）让T2先执行；
            2、什么是java 内存模型JMM？
                ---主内存储存共享变量、本地内存储存共享变量的副本

            3、ThreadLoca作用是？
                ---ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用。
                作用：提供一个线程内公共变量（比如本次请求的用户信息），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个私有的变量副本
                这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

            4、ThreadLock的原理是什么---
                ---ThreadLocal，连接ThreadLocalMap和Thread。来处理Thread的TheadLocalMap属性，包括init初始化属性赋值、get对应的变量，set设置变量等.
                通过当前线程，获取线程上的ThreadLocalMap属性，对数据进行get、set等操作。
                ThreadLocalMap，用来存储数据，采用类似hashmap机制，存储了以threadLocal为key，需要隔离的数据为value的Entry键值对数组结构。
                ThreadLocal，有个ThreadLocalMap类型的属性，存储的数据就放在这儿。

            5、threadLocal内存泄漏？解决？
            ---在TreadLocal中内存泄漏是指TreadLocalMap中的Entry中的key为null，而value不为null。因为key为null导致value一直访问不到，而根据可达性分析，始终有threadRef->currentThread->threadLocalMap->entry->valueRef->valueMemory,
                导致在垃圾回收的时候进行可达性分析的时候,value可达从而不会被回收掉，但是该value永远不能被访问到，这样就存在了内存泄漏。
               因为Entry的key是弱引用，所以在gc的时候key会被回收，而value是强引用，导致value不会被回收。
               如果不使用弱引用也会可能会发生内存泄漏，只要在业务代码里，将ThreadLocal的引用置为null，也会导致Entry中value访问不到,但又因为可达，所以gc时候不会被回收，相当于这部分内存资源被浪费了
               解决？当ThreadLocalMap 中的entry的key为null的时候要及时remove掉这个entry

            6、volatile和ssynchronized的区别是什么?
                ---volatile可以保证线程之间的可见性和禁止重排序，但是不能保证线程的原子性操作；
                    而synchronized可以保证线程之间的原子性和可见性

            7、什么是重排序？
                ---重排序就是jvm为了优化程序性能，执行程序的时候并不一定是由上到下顺序执行，而是在保证执行结果不变的情况下执行顺序会发生改变

            8、什么情况下，重排序对程序有影响？
                ---多线程情况下，代码之间有依赖关系的时候
                例如：a = 1;  //1行
                     b = 2;   //2行
                     c = a + b;  //3行
                     第三行代码依赖第一第二行，无论第一第二行谁先执行，第三行都是最后执行的，保证结果正确


            9、怎么保证线程的可见性？
                ---对共享数据加volatile  synchronized也可以

            10、谈谈你对并发队列的理解？
                ---jdk提供了两套并发队列的实现；
                    分别是：以ConcurrentLinkedQueue为代表的高性能无阻塞队列
                    以BlockingQueue为代表阻塞式队列

            11、有界队列和无界队列的区别？
                ---有界：指定队列容器的最大值，防止队列溢出和数据丢失
                   无界：大小不指定（其实默认最大值为Integer.Max=2^31-1）

            12、非阻塞队列和阻塞队列的区别-----线程等待与不等待？
                ---阻塞式：BlockingQueue:指定大小，有界（防止队列溢出，数据丢失），线程池就是使用的阻塞式队列；
                   非阻塞式：ConcurrentLinkedQueue:不指定大小，无界（伪有界，最大值为Integer.Max=2^31-1）

            13、你了解哪些jdk的并发包？
                ---并发队列、原子类、线程池、并发集合

            14、线程池有哪些分类？
                ---缓存线程池、固定大小线程池、定长定时任务线程池、单线程线程池

            15、线程池的实现原理？
                ---通过阻塞式队列，BlockingQueue、对ThreadPoolExecuter的封装

            16、线程池配置多大合适？
                ---根据io密集：线程任务存在大量的读写操作，存在严重的阻塞等待情况，线程池线程配置的数量为 2*pcu的核数
                    cpu密集：线程任务无阻塞，就不用创建过多的线程了，避免造成浪费；这时候线程池的线程数量 =cpu的核数

            17、ThreadPoolExcecutor有哪些参数？
                ---核心线程数、最大线程数、线程空闲时间、缓冲队列


            18、你了解哪些锁？
                ---重量级锁、轻量级锁、悲观锁、乐观锁、读写锁、公平锁、非公平锁、自旋锁、cas无锁

            19、乐观锁和悲观锁区别？
                ---乐观锁：无锁，不会造成线程的阻塞 ；比如 数据库表加version字段、cas无锁 都属于乐观锁
                   悲观锁：有锁 会阻塞等待：比如：synchronized

            20、你用过哪些源自类？
                ---AtomicInteger、AtomicLong、AtomicIntegerArray、AtomicIntegerReference、AtomicIntegerFieldUpdate

            21、原子类的实现原理？
                ---cas无锁机制：jmm--比较置换--失败重试

            22、什么式cas无锁机制？
                ---jmm内存模型--cas（CompareAndSet；V和E 相等则N置换V，不等则重试）

            23、cas用的是什么锁
                ---自旋锁:do--while,不放弃cpu争夺权，一直在自旋等待锁对象；这就免去了线程从执行--阻塞--执行的对性能的消耗
                    缺点是：消耗了cpu资源又不一定能获取到锁从而去执行任务，这就可能导致对cpu的白白浪费

            24、自旋锁和互斥锁的区别？
                ---自旋锁相当于乐观锁、互斥锁就相当于悲观锁

            25、什么是future模式?
                ---异步线程可以返回结果,先用一个future对象去接收预期的返回值，等真正执行完的时候在拿真正的值；

            26、callable和Thread的区别?
                ---一个有返回值，并且可以异步获取返回值，不影响主线程取执行其他的操作，一个没有返回值，且子线程产生的阻塞，会影响主线程执行其他的操作

            27、你了解哪些并发框架?
                ---第三方：disruptor，fork/join

            28、如何检测死锁?
                ---JConsole、VisualVm

            29、Lock锁的底层原理是什么?
                ---Aqs,双向链表

            30、AQS底层实现原理?
                ---
            31、你有了解过Aqs吗?
                ---

            32、synchronized的底层实现原理?
                ---

            33、加锁是如何影响效率的？
                ---多个线程共享同一资源，拿不到锁的线程会阻塞挂起做不了其他事；
                    从阻塞挂起到拿到锁执行这一过程极大消耗性能；
                    优先级高的线程拿不到锁被阻塞，优先级低的线程拿到锁执行，造成优先级反转