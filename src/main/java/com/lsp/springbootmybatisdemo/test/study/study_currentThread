编发编程：
    多线程

        基本概念：
            进程：每一个正在计算机内运行的应用程序都是一个进程，进程是操作系统进行资源调度分配的基本单位，是线程的集合
            线程：线程是进程的基本单位，每一个线程都是进程中一条执行路径，线程是宝贵的资源
            多线程：一个进程中有多条执行路径，也就是有多个线程在执行；例如迅雷同时下载多部电影、数据库连接池原理
                优点：提高程序的执行效率
            并发：在同一个进程内，多个线程共同竞争同一个cpu的执行权，宏观上看是多个线程同步执行，实际上是spu快速切换给线程分配执行权
            并行：指两个或两个以上事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源上（多核），同时执行。
            线程安全：在多线程并发情况下，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。
                解决线程安全问题：使用synchronized（内置锁）关键字或着线程锁（Lock）
            线程同步：当多个线程共享同一个资源,不会受到其他线程的干扰。
                作用：保证共享数据的读操作安全
                缺点：一个线程在执行共享数据的时候，其他的线程会处于阻塞状态，会降低程序的性能，多个线程需要判断锁，较为消耗资源
            死锁：同步中嵌套着同步；两个线程一双筷子的举例，若每个线程都持有一根筷子，且都在等待另一根筷子，若无外力作用，则两线程一直处于阻塞状态，这就叫死锁。
                解决方法：1、现让一个线程执行获得所有锁执行，另一个线程等待，等先执行的线程执行完毕，在让等待的线程去执行

        多线程的常见创建方式
            继承thread：
            实现Runnable：
            两者比较：实现效果相同，但是实现可以多实现，继承只能单继承，存在局限性
            start()和run（）区别:start()，开启线程，是线程进入就绪状态，等待spu分配资源，拿到cpu执行权才整整执行；run()线程的执行体，线程执行的内容

        线程五状态：
            线程创建状态
            就绪状态
            运行状态
            阻塞状态
            结束

        线程调度：
            线程休眠 sleep()：线程进入阻塞状态，暂时让出cpu执行权，休眠时间结束又进入就绪状态；线程同步情况下，不会让出锁对象
            线程合并 join（）:A、B线程共享同一资源，A线程在执行的时候调用B线程的join(),A会处于阻塞转态，让出cpu执行权，B线程占用cpu执行权，待B线程执行完毕，A线程重新进入就绪状态
            线程礼让 yield():yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。线程之间拥有优先级，可以给线程手动设置优先级：threadA.setPriority()，一般来说线程优先级高的获得cpu执行权的机会大，单事无绝对
            线程中断：线程执行完毕之后自藕丁中断：public void stop()   线程执行过程中遇到异常中断：public void interrupt()   线程在执行的时候手动中断：public boolean isInterrupt()
            sleep()和join()区别：线程同步情况下，sleep（）不会让出锁对象，而join（）会让出锁对象

        线程之间的通信：多线程的同步需要线程之间的协同通信
            1、wait()/notify():wait（）使得正在运行的线程进入阻塞状态，等待唤醒；notify()唤醒阻塞的线程；
            2、ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()

        线程锁：
            内置锁：每一个java对象都可以当做一个实现线程同步的锁,称为内置锁；线程进入到同步代码块之前自动获取到锁，代码块执行完成或者是或者出现异常退出的时候会释放掉锁
                   synchronized：synchronized 修饰对象方法使用锁是当前this锁；synchronized 修饰静态方法使用锁是当前类的字节码文件
            Lock锁：在jdk1.5以后，在并发包中新增了Lock接口（以及相关的实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但是需要在使用的时候手动的上锁和解锁。
                    Lock接口可以尝试非阻塞的获取锁，当前线程尝试获取锁。如果这一时刻没有锁没有被其他的线程获取到，并成功的获取并持有锁。
                    Lock接口能被中断的获取锁，与synchronized不同，获取到锁的线程能够像响应中断，当获取到的锁被中断的时候，中断异常将会被抛出，同时锁会被释放
                    Lock接口在指定的时间之前获取到锁，如果时间到了依旧无法获取到锁，则返回。
            重入锁：重入锁也叫作递归锁，指的是同一函数获得锁之后，内层函数仍然有获取该锁的代码，但是不受影响
                    在java环境下，ReentranLock(显示锁、轻量级锁)、synchronized(内置锁、互斥锁)都属于重入锁
            读写锁：假设程序中存在一些对共享资源的读写操作，且写操作没有读操作那么频繁；在没有写操作的时候，两个线程读取同一资源没有任何问题，所以他是允许多线程同时读取
                    共享资源的；但是如果一个线程想去写这些共享数据，就不应该再有其他的读或者写线程对该共享资源进行操作。这时候读写锁就出现了
                    一句话总结：多个读写线程对共享资源进行读写操作的时候可以读--读、不可以读-写、写-写
            乐观锁和悲观锁：
                乐观锁：总是认为不会发生并发问题，每次去取数据的时候总认为不会有其他的线程对数据进行修改，因此不会上锁；
                        但是在更新数据的时候会判断在这之前有没有其他的线程对数据进行修改，一般使用版本号机制或者ca操作实现
                    version方式：一般是在数据库表中加一个数据版本号字段version，表示数据表被修改的次数，当数据表被修改时，version会+1,；当线程A要更新数据的时候
                        在读取数据的同时也会读取到version的值，在提交更新时，当刚才读取的version值和当前数据库中的version值相等时才更新；
                        个人理解，比如：A B两个线程要同时修改表中的同一条数据，假设现在这条数据的版本号是2；现在A、B两个线程同时读取到这条数据的版本号都是2；然后开始执行修改操作,但是都还没提交;
                        这时候B修改好了，要提交操作时发现表中的这条数据的版本号还是2，说明他在做修改操作的时候，没有其他线程对这条数据做修改操作，所以线程B很顺利的就提交了操作，并且这条数据的
                        版本好由2变成了3； 这时候A线程也修改好了，要提交修改操作的时候发现当前数据库表中的这条数据的版本号变成了3，跟他拿到的版本号2不一样，没办法，A线程就得放弃当前的提交操作，重新获取当前
                        版本的数据进行修改，一直重试，知道提交成功；、
                    CAS方式：即Compare and Swap 比较然后置换；涉及到三个操作数，分别是数据所在的内存值（V）、预期值（E）、新值(N);
                        当需要进行更新操作的时候，会先判断当前内存值与之前取到的值是否相等，若相等，则那新值更换内存值，若不相等则等于失败那就会重试，一般情况下是一个自选的操作，会不断的重试；
                悲观锁：总是假设最坏的情况，每次取数据的时候都会认为其他线程会对数据进行修改操作，所以为安全起见都会进行加锁（读锁、写锁），当其他线程需要访问数据时候
                        就会被挂起阻塞；悲观锁可以靠数据库实现、比如行锁、读锁、写锁等..都是在操作之前加的锁，在java中synchronized的思想是悲观锁

        原子类：



        多线程的三大性质：
            原子性：一个或者多个操作要么全部执行不受其他因素的影响，要么全部不执行；典型例子：银行转账
            可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值
            有序性：程序执行的顺序按照代码的先后顺序执行；一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，
                    它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
                    重排序在对单线程是不会有问题的，但是对于多线程就不一定了

        java内存模型（JMM）:JMM决定一个线程对共享变量写入时，能对另一线程可见；
                     线程之间的共享变量储存在主内存中，每个线程都有一个私有的本地内存，本地内存储存了共享变量的读写副本

        volatile:一旦某个线程修改了被volatile修饰的属性，修改后的属性就会被立即刷新到主内存中，当有其他的线程需要读取时，可以获取到修改后的值；
                在Java中为了加快程序的运行效率，对一些变量的操作通常是放在寄存器或者cpu的缓存上，之后才会同步到住内存中；而加了volatile是直接把变量读到主内存中；
                volatile保证了线程的可见性并且禁止重排序，但是不能保证原子性。
                volatile性能：volatile的读性能与普通变量几乎相同，但是写操作稍慢，因为他需要再本地代码中插入许多内屏指令来保证处理器不发生乱序现象

        volatile与synchronized的区别：
            1、volatile虽然保证了可见性但是并不能保证原子性；synchronized保证原子性和可见性
            2、性能方面：synchronized是使多线程同步，防止同一时刻多个线程对共享数据进行写操作，其他线程就会处于阻塞状态；
            而在某些情况下，volatile的性能要优于synchronized,但是volatile是无法替代synchronized的，因为他无法保证线程的原子性

        并发队列：阻塞与非阻塞：入列（添加队列），出列（获取队列）的时候线程是否会发生阻塞
            1：非阻塞式队列：例如-ConcurrentLinkedQueue（无界队列，不设大小，其实底层式用扩容实现的，看起来是无界）
                ConcurrentLinkedQueue:是一个适用于高并发场景下的队列，通过无锁的方式，实现高并发状态下的高性能，通常ConcurrentLinkedQueue的性能要优于Blocking，它是一个基于连接节点的无界线程安全队列，改队列遵循现金先出的原则
            2：阻塞式队列：例如-BlockingQueue（有界队列，大小式有限制的）
                阻塞：队列容器满了，则往队列容器中添加队列的操作会阻塞（等待时间可以设置），直到队列容器中有空闲位置；当队列容器中的为空了，则试图从容器中获取队列的操作会被阻塞，直到生产者往队列容器中生产存放队列，则继续从中获取队列
                ArrayBlockingQueue:是一个有边界的阻塞阻塞队列，他的内部实现是一个数组，有边界就是要指定队列大小
                LinkedBlockingQueue:阻塞队列的大小是可选的，如果我们初始化一个大小，他就是有界的，否则他就是无界的，无界的不指定具体大小，则存在一个默认最大值：Integer.MAX_VALUE  2^31-1；内部基于单向链表
                PriorityBlockingQueue:是一个没有边界的队列
                SynchronousQueue：队列内部仅允许容纳一个元素，当一个线程插入一个元素后 被阻塞，除非这个元素被其他的线程消费

        线程池：
            概念：储存可复用线程的池叫线程池，Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池；底层是阻塞式队列（防止队列容器溢出导致数据丢失）
                 使用线程池的三个好处
                 1、降低资源消耗：通过重复利用已经创建的线程降低线程创建和销毁锁造成的消耗（线程五状态）
                 2、提高响应速度：当任务到达时，可以不需要等待线程的创建就可以立即执行
                 3、提高线程的可管理性：线程是稀缺的资源，如果无限的创建，不仅会消耗系统的资源，还会降低系统的稳定性,使用线程池可以进行统一分配、调优和监控；但是要合理利用
            创建线程池的参数： new ThreadPoolExecutor(CorePoolSize, maximumPoolSize,keepAliveTime, TimeUnit,new SynchronousQueue<Runnable>());
                1、CorePoolSize:核心线程数（工作线程数），实际在执行的线程的个数；当任务线程数大于核心数，则多余的会存到缓存队列；核心线程数小于等于最大线程数
                2、maximumPoolSize：线程池最大的线程数，他表示的是线程池中最多能创建多少个线程
                3、keepAliveTime：线程的空闲时间
                4、SynchronousQueue：缓存队列
            线程池的四种创建方式：
                1、Executors.newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
                2、Executors.newFixedThreadPool ：创建一个固定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
                3、Executors.newScheduledThreadPool :创建一个固定长度的线程池，支持定长以及周期性任务执行
                4、Executors.newSingleThreadExecutor :创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
            线程池原理分析：提交一个任务到线程池中，线程池的处理流程如下：
                1、先判断线程池中的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务，否则进入下一个流程；（敢死队是否已经满，若未满，则新创建一个加入敢死队，否则下一个流程）
                2、线程池判断线程缓存队列是否已经满了，如果没有满，则把新提交的任务储存在这个缓存队列中，如果队列缓存满了，则进入下一个流程
                3、判断线程池中创建的线程数目是否已经达到规定的最大的线程数目，如果没有，则创建一个新的工作线程，否则交给饱和策略来处理这个任务；
            合理配置线程池：看任务执行情况，判断是IO密集型还是cpu密集型
                IO密集型：该任务会产生大量的IO阻塞，比如请求、读取数据库、循环IO操作等都可能发生阻塞，如果是在单线程的情况下，解决这种情况，可以使用多线程取解决；
                        这时候线程池最大的线程数配置为 2*cpu的核数，比如我的电脑是八核的，那么我的最大线程数可以配置为16
                CPU密集：CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。这时候没有产生阻塞情况，cpu不用等待可以一直快速执行，多任务的时候也是采用多线程取取提高程序的运行效率
                        cpu密集不用配置过多的线程数量，线程池配置的最大线程数为cpu核数就行，配置多大，造成浪费；比如我的电脑是八核的，那么最大线程数配置为8就行

        callable和Future: 在Java中，创建线程一般有两种方式，一种是继承Thread类，一种是实现Runnable接口。然而，这两种方式的缺点是在线程任务执行结束后，无法获取执行结果。
                          我们一般只能采用共享变量或共享存储区以及线程通信的方式实现获得任务结果的目的。Java提供了使用Callable和Future来实现获取任务结果的操作。
            Callable:Callable用来执行任务，产生结果;Callable与Runnable的差别在于Callable的Call方法带有反省返回值
            Future:Future用来异步获取结果。
            Future模式：Future模式的核心在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑；
                        比如：对于多线程，如果线程A要等待线程B的结果，那么线程A没必要等待B，直到B有结果，可以先拿到一个未来的Future，等B有结果是再取真实的结果。
                        经常举的一个例子就是：网络图片的下载，刚开始是通过模糊的图片来代替最后的图片，等下载图片的线程下载完图片后在替换。而在这个过程中可以做一些其他的事情。
                        自己的理解：比如说你煮饭的时候又想完游戏，但是如果你是用柴火煮饭的，那么你玩游戏的时候，就可能完一会游戏又得跑去看看柴火，就会影响你玩游戏，虽然也可以玩，但是断断续续的。极大影响游戏体验
                        但是如果你是用电饭煲，那你插上电就不用管了，直接一边电饭煲煮饭，你玩你的游戏，饭熟了，你游戏可能也打完了，完全不影响你玩游戏，电饭锅会自己停止，你直接那碗取盛饭就行






        思考题、面试题：
            1、假设有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行，
            答：使用线程合并方法进行线程的一个调度，在T2执行的时候调用T1.join,让T1先执行完毕；T3执行的时候调用T2.join（）让T2先执行；
            2、什么是java 内存模型JMM---主内存、本地内存
            3、ThreadLoca作用是---
            4、ThreadLock的原理是什么---
            5、threadLocal内存泄漏---
            6、volatile和ssynchronized的区别是什么
            7、什么是重排序
            8、什么情况下，重排序对程序有影响------多线程情况下
            9、怎么保证线程的可见性-------对共享数据加violatile  synchronized也可以
            10、谈谈你对并发队列的理解----阻塞式，非阻塞式
            11、有界队列和无界队列的区别----
            12、非阻塞队列和阻塞队列的区别-----线程等待与不等待
            13、你了解哪些jdk的并发包---源自类、并发队列
            14、线程池有哪些分类----四种，对ThreadPoolExecuter的封装
            15、线程池的实现原理-----通过阻塞式队列，BlockingQueue
            16、线程池配置多大合适----=根据io密集  、cpu密集
            17、ThreadPoolExcecutor有哪些参数---核心线程数、最大线程数、线程空闲时间、缓冲队列
            18、你了解哪些锁---重量级锁、轻量级锁、悲观锁、乐观锁、读写锁、公平锁、非公平锁
            19、乐观锁和悲观锁区别---乐观锁无锁、悲观锁有锁 回阻塞等待
            20、你用过哪些源自类---AtomicInteger--
            21、源自类的实现原理--cas无锁机制
            22、什么式cas无锁机制？----jm内存模型、---
            23、cas用的是什么锁-----自旋锁
            24、自旋锁和互斥锁的区别？-------悲观乐观锁
            25、什么是future模式------异步线程可以返回结果
            26、callable和Thread的区别------一个有返回值，并且可以异步获取返回值，不影响主线程取执行其他的操作，一个没有返回值，且子线程产生的阻塞，会影响主线程执行其他的操作
            27、你了解哪些并发框架--------第三方disruptor，fork/join
            28、如何检测死锁-----jconsole、visualvm
            29、Lock锁的底层原理是什么----Aqs,双向链表
            30、AQS底层实现原理----
            31、你有了解过Aqs吗----
            32、synchronized的底层实现原理---