编发编程：
    多线程

        基本概念：
            进程：每一个正在计算机内运行的应用程序都是一个进程，进程是操作系统进行资源调度分配的基本单位，是线程的集合
            线程：线程是进程的基本单位，每一个线程都是进程中一条执行路径，线程是宝贵的资源
            多线程：一个进程中有多条执行路径，也就是有多个线程在执行；例如迅雷同时下载多部电影、数据库连接池原理
                优点：提高程序的执行效率
            并发：在同一个进程内，多个线程共同竞争同一个cpu的执行权，宏观上看是多个线程同步执行，实际上是spu快速切换给线程分配执行权
            并行：指两个或两个以上事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源上（多核），同时执行。
            线程安全：在多线程并发情况下，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。
                解决线程安全问题：使用synchronized（内置锁）关键字或着线程锁（Lock）
            线程同步：当多个线程共享同一个资源,不会受到其他线程的干扰。
                作用：保证共享数据的读操作安全
                缺点：一个线程在执行共享数据的时候，其他的线程会处于阻塞状态，会降低程序的性能，多个线程需要判断锁，较为消耗资源
            死锁：同步中嵌套着同步；两个线程一双筷子的举例，若每个线程都持有一根筷子，且都在等待另一根筷子，若无外力作用，则两线程一直处于阻塞状态，这就叫死锁。
                解决方法：1、现让一个线程执行获得所有锁执行，另一个线程等待，等先执行的线程执行完毕，在让等待的线程去执行

        多线程的常见创建方式
            继承thread：
            实现Runnable：
            两者比较：实现效果相同，但是实现可以多实现，继承只能单继承，存在局限性
            start()和run（）区别:start()，开启线程，是线程进入就绪状态，等待spu分配资源，拿到cpu执行权才整整执行；run()线程的执行体，线程执行的内容

        线程五状态：
            线程创建状态
            就绪状态
            运行状态
            阻塞状态
            结束

        线程调度：
            线程休眠 sleep()：线程进入阻塞状态，暂时让出cpu执行权，休眠时间结束又进入就绪状态；线程同步情况下，不会让出锁对象
            线程合并 join（）:A、B线程共享同一资源，A线程在执行的时候调用B线程的join(),A会处于阻塞转态，让出cpu执行权，B线程占用cpu执行权，待B线程执行完毕，A线程重新进入就绪状态
            线程礼让 yield():yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。线程之间拥有优先级，可以给线程手动设置优先级：threadA.setPriority()，一般来说线程优先级高的获得cpu执行权的机会大，单事无绝对
            线程中断：线程执行完毕之后自藕丁中断：public void stop()   线程执行过程中遇到异常中断：public void interrupt()   线程在执行的时候手动中断：public boolean isInterrupt()
            sleep()和join()区别：线程同步情况下，sleep（）不会让出锁对象，而join（）会让出锁对象

        线程之间的通信：多线程的同步需要线程之间的协同通信
            1、wait()/notify():wait（）使得正在运行的线程进入阻塞状态，等待唤醒；notify()唤醒阻塞的线程；
            2、ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()

        线程锁：
            内置锁：每一个java对象都可以当做一个实现线程同步的锁,称为内置锁；线程进入到同步代码块之前自动获取到锁，代码块执行完成或者是或者出现异常退出的时候会释放掉锁
                   synchronized：synchronized 修饰对象方法使用锁是当前this锁；synchronized 修饰静态方法使用锁是当前类的字节码文件
            Lock锁：在jdk1.5以后，在并发包中新增了Lock接口（以及相关的实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但是需要在使用的时候手动的上锁和解锁。
                    Lock接口可以尝试非阻塞的获取锁，当前线程尝试获取锁。如果这一时刻没有锁没有被其他的线程获取到，并成功的获取并持有锁。
                    Lock接口能被中断的获取锁，与synchronized不同，获取到锁的线程能够像响应中断，当获取到的锁被中断的时候，中断异常将会被抛出，同时锁会被释放
                    Lock接口在指定的时间之前获取到锁，如果时间到了依旧无法获取到锁，则返回。

        多线程的三大性质：
            原子性：一个或者多个操作要么全部执行不受其他因素的影响，要么全部不执行；典型例子：银行转账
            可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值
            有序性：程序执行的顺序按照代码的先后顺序执行；一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，
                    它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
                    重排序在对单线程是不会有问题的，但是对于多线程就不一定了

        java内存模型（JMM）:JMM决定一个线程对共享变量写入时，能对另一线程可见；
                     线程之间的共享变量储存在主内存中，每个线程都有一个私有的本地内存，本地内存储存了共享变量的读写副本

        volatile:一旦某个线程修改了被volatile修饰的属性，修改后的属性就会被立即刷新到主内存中，当有其他的线程需要读取时，可以获取到修改后的值；
                在Java中为了加快程序的运行效率，对一些变量的操作通常是放在寄存器或者cpu的缓存上，之后才会同步到住内存中；而加了volatile是直接把变量读到主内存中；
                volatile保证了线程的可见性并且禁止重排序，但是不能保证原子性。
                volatile性能：volatile的读性能与普通变量几乎相同，但是写操作稍慢，因为他需要再本地代码中插入许多内屏指令来保证处理器不发生乱序现象

        volatile与synchronized的区别：
            1、volatile虽然保证了可见性但是并不能保证原子性；
            2、性能方面：synchronized是使多线程同步，防止同一时刻多个线程对共享数据进行写操作，其他线程就会处于阻塞状态；
            而在某些情况下，volatile的性能要优于synchronized,但是volatile是无法替代synchronized的，因为他无法保证线程的原子性

        并发队列：
            1：非阻塞式队列：例如-ConcurrentLinkedQueue
                ConcurrentLinkedQueue:是一个适用于高并发场景下的队列，通过无锁的方式，实现高并发状态下的高性能，通常ConcurrentLinkedQueue的性能要优于Blocking，它是一个基于连接节点的无界线程安全队列，改队列遵循现金先出的原则
            2：阻塞式队列：例如-BlockingQueue
                阻塞：队列容器满了，则往队列容器中添加队列的操作会阻塞，直到队列容器中有空闲位置；当队列容器中的为空了，则试图从容器中获取队列的操作会被阻塞，直到队列容器中存在队列，则继续从中获取队列
                ArrayBlockingQueue:是一个有边界的阻塞阻塞队列，他的内部实现是一个数组，有边界就是要指定队列大小
                LinkedBlockingQueue:阻塞队列的大小是可选的，如果我们初始化一个大小，他就是有界的，否则他就是无界的，无界的不指定具体大小，则存在一个默认最大值：Integer.MAX_VALUE  2^31-1；内部基于单向链表
                PriorityBlockingQueue:是一个没有边界的队列
                SynchronousQueue：队列内部仅允许容纳一个元素，当一个线程插入一个元素后 被阻塞，除非这个元素被其他的线程消费

        线程池：
            概念：储存可复用线程的池叫线程池，Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。
                 使用线程池的三个好处
                 1、降低资源消耗：通过重复利用已经创建的线程降低线程创建和销毁锁造成的消耗
                 2、提高响应速度：当任务到达时，可以不需要等待线程的创建就可以立即执行
                 3、提高线程的可管理性：线程是稀缺的资源，如果无限的创建，不仅会消耗系统的资源，还会降低系统的稳定性,使用线程池可以进行统一分配、调优和监控；但是要合理利用
            创建线程池的参数： new ThreadPoolExecutor(CorePoolSize, maximumPoolSize,keepAliveTime, TimeUnit,new SynchronousQueue<Runnable>());
                1、CorePoolSize:核心池的大小，真正执行的线程的个数；当任务线程数大于核心数，则多余的会存到缓存队列
                2、maximumPoolSize：线程池最大的线程数，他表示的是线程池中最多能创建多少个线程
                3、keepAliveTime：线程的空闲时间
                4、SynchronousQueue：缓存队列
            线程池的四种创建方式：
                1、Executors.newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
                2、Executors.newFixedThreadPool ：创建一个固定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
                3、Executors.newScheduledThreadPool :创建一个固定长度的线程池，支持定长以及周期性任务执行
                4、Executors.newSingleThreadExecutor :创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
            线程池执行原理：提交一个任务到线程池中，线程池的处理流程如下：
                1、先判断线程池中的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务，否则进入下一个流程；（敢死队是否已经满，若未满，则新创建一个加入敢死队，否则下一个流程）
                2、线程池判断线程缓存队列是否已经满了，如果没有满，则把新提交的任务储存在这个缓存队列中，如果队列缓存满了，则进入下一个流程
                3、判断线程池中创建的线程数目是否已经达到规定的最大的线程数目，如果没有，则创建一个新的工作线程，否则交给饱和策略来处理这个任务；




        思考题：
            1、假设有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行，
            答：使用线程合并方法进行线程的一个调度，在T2执行的时候调用T1.join,让T1先执行完毕；T3执行的时候调用T2.join（）让T2先执行；